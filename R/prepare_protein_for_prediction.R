#' Assemble a sliding window representation of an unlabeled protein
#'
#' This function is used to turn protein sequences into windowed
#' representations, with rows corresponding to a fixed-length window that slides
#' over the protein. This function is analogous to
#' `assemble_windowed_dataframe()`, but it works with only a `protein` dataframe
#' (generated by `get_proteins()`).
#'
#' If the windowed dataframe is to be used for prediction, it is important to
#' use the same `window_size` that was used to assemble the training dataset in
#' `assemble_windowed_dataframe()`, so that equivalent features can be
#' calculated (notice that sometimes `window_size` is determined automatically
#' in `assemble_windowed_dataframe()` as `max(3, (2 * min_epit) - 1)`).
#'
#' @param proteins data frame of protein data (returned by [get_proteins()].
#' @param save_folder path to folder for saving the results.
#' @param window_size positive integer, size of window to use (see `Details`)
#' @param ncpus positive integer, number of cores to use (multi-core
#'        capabilities not yet available for Windows systems.)
#'
#' @return A data frame containing the extracted windows is returned invisibly.
#' Each row of the resulting data frame will have the protein ID,
#' windowed sequence, and other variables that may be useful for
#' mapping each window to its position on the protein sequence.
#'
#' @author Felipe Campelo (\email{f.campelo@@aston.ac.uk})
#'
#' @importFrom dplyr "%>%"
#' @importFrom rlang .data
#'
#' @export
#'
#' @examples
#' proteins <- data.frame(molecule_id = c("P.001", "A.002"),
#'               TSeq_sequence = c("TYGACPKYVKQNTLKLATLKLATGMRNVPEKQT",
#'                 "LPKEEKKDDPPKDPKKDDPPKEAQNKLNQPVVADENVDQGPGAPQGPGAPQGPGAPQGPGAPQGPGAPQGPGAPQ"),
#'               TSeq_taxid = c(NA,NA),
#'               TSeq_orgname = c(NA,NA),
#'               stringsAsFactors = FALSE)
#'
#' x <- prepare_protein_for_prediction(proteins, window_size = 15)
#'

prepare_protein_for_prediction <- function(proteins,
                                           window_size,
                                           save_folder  = NULL,
                                           ncpus        = 1){

  # ========================================================================== #
  # Sanity checks and initial definitions
  assertthat::assert_that(assertthat::is.count(window_size),
                          is.data.frame(proteins),
                          is.null(save_folder) | (is.character(save_folder)),
                          is.null(save_folder) | length(save_folder) == 1,
                          assertthat::is.count(ncpus))

  # Set up parallel processing
  if ((.Platform$OS.type == "windows") & (ncpus > 1)){
    cat("\nAttention: multicore not currently available for Windows.\n
        Forcing ncpus = 1.")
    ncpus <- 1
  } else {
    available.cores <- parallel::detectCores()
    if (ncpus >= available.cores){
      cat("\nAttention: ncpus too large, we only have ", available.cores,
          " cores.\nUsing ", available.cores - 1,
          " cores for run_experiment().")
      ncpus <- available.cores - 1
    }
  }

  # Check save folder and create file names
  if(!is.null(save_folder)) {
    if(!dir.exists(save_folder)) dir.create(save_folder)
    df_file <- paste0(normalizePath(save_folder), "/df_windowed.rds")
  }

  # ========================================================================== #
  # Initial preprocessing

  # Join epitopes and proteins dataframes, preliminary feature transformation
  df <- proteins %>%
    dplyr::transmute(protein_id    = as.character(.data$molecule_id),
                     protein_seq   = as.character(.data$TSeq_sequence),
                     protein_len   = nchar(.data$TSeq_sequence),
                     protein_taxid = as.character(.data$TSeq_taxid),
                     org_name      = as.character(.data$TSeq_orgname))

  # ========================================================================== #
  # Generate dataframe by sliding windows
  # get_prot_window() is defined at the bottom of this file.
  cat("\nExtracting windows:\n")
  mydf <- pbmcapply::pbmclapply(X = purrr::pmap(as.list(df), list),
                                FUN            = get_prot_window,
                                ws             = window_size,
                                mc.cores       = ncpus,
                                mc.preschedule = FALSE)

  cat("\nAssembling windowed dataframe...")
  mydf <- data.frame(data.table::rbindlist(mydf))

  # Save resulting dataframe and error IDs to file
  if(!is.null(save_folder)) {
    saveRDS(mydf, file = df_file)
  }

  invisible(mydf)
}

get_prot_window <- function(x, ws){
  wdf <- data.frame(window_seq = rep(NA_character_, x$protein_len),
                    taxid      = x$protein_taxid,
                    protein_id = x$protein_id,
                    center_pos = rep(NA_integer_, x$protein_len),
                    stringsAsFactors = FALSE)
  for (i in 1:x$protein_len){
    i1   <- max(1, min(i - floor(ws / 2), x$protein_len - ws + 1))
    i2   <- min(x$protein_len, i1 + ws - 1)
    wdf$window_seq[i] <- substr(x$protein_seq, i1, i2)
    wdf$center_pos[i] <- i
  }
  return(wdf)
}
