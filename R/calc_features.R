#' Calculate statistical and physicochemical features for peptides
#'
#' This function is used to calculate several distinct families of features for
#' a vector of peptides.
#'
#' This function is partially based on functions [Peptides::aaComp()]
#' and [Peptides::aaDescriptors()] (check documentation for details).
#'
#' Some of the features are calculated based on an aminoacid propensity scale,
#' which was originally obtained from *E.L. Ulrich et al., "BioMagResBank".
#' Nucleic Acids Research 36, D402-D408 (2008) DOI: 10.1093/nar/gkm957*. The
#' data was downloaded from
#' [http://www.bmrb.wisc.edu/ref_info/aadata.dat](http://www.bmrb.wisc.edu/ref_info/aadata.dat)
#' on July 1, 2020.
#'
#' @param df a *data.table* of class *windowed_epit_dt* or *windowed_prot_dt*,
#'        generated by [make_window_df()]
#' @param max.N maximum length of N-peptide frequency features to be calculated.
#'              See [calc_Npeptide_composition()] for details.
#' @param ncpus number of cores to use for calculating some of the features.
#' @param save_folder path to folder for saving the output.
#'
#' @return Data table containing the calculated features appended as new columns.
#'
#' @author Felipe Campelo (\email{f.campelo@@aston.ac.uk});
#'         Jodie Ashford (\email{ashfojsm@@aston.ac.uk})
#'
#' @importFrom dplyr %>%
#' @export
#'
calc_features <- function(df,
                          max.N = 2,
                          ncpus = 1,
                          save_folder = NULL){
  # ========================================================================== #
  # Sanity checks and initial definitions
  df_classes <- c("windowed_epit_dt", "windowed_prot_dt")
  assertthat::assert_that(is.data.frame(df),
                          any(class(df) %in% df_classes),
                          assertthat::is.count(max.N),
                          assertthat::is.count(ncpus))

  type <- "prot"
  if("windowed_epit_dt" %in% class(df)){
    type <- "epit"
  }

  # Set up parallel processing
  available.cores <- parallel::detectCores()
  if (ncpus > available.cores){
    cat("\nAttention: cores too large, we only have ", available.cores,
        " cores.\nUsing ", available.cores - 1,
        " cores for get_LBCE().")
    ncpus <- max(1, available.cores - 1)
  }

  cl <- ncpus
  if (ncpus > 1){
    if (.Platform$OS.type == "windows"){
      cl <- parallel::makeCluster(ncpus, setup_timeout = 1)
    }
  }

  # Check save folder and create file names
  if(!is.null(save_folder)) {
    if(!dir.exists(save_folder)) dir.create(save_folder)
    ymd <- gsub("-", "", Sys.Date())
    df_file <- paste0(normalizePath(save_folder), "/", ymd, "_df_", type,
                      "_feats.rds")
    errfile <- paste0(normalizePath(save_folder), "/", ymd, "_df_", type,
                      "_removed.rds")
  }

  aa_codes <- get_aa_codes()
  invalid <- which(!sapply(df$Info_window_seq,
                           function(x){
                             all(strsplit(x, split = "")[[1]] %in% aa_codes)
                           }))

  if(length(invalid) > 0){
    errlist <- df[invalid, ]
    df      <- df[-invalid, ]
    if(!is.null(save_folder)) saveRDS(errlist, errfile)
  }
  # ========================================================================== #

  # Calculate features
  cat("\nCalculating features:")

  df <- df %>%
    calc_aa_composition(cl = cl) %>%
    calc_aa_descriptors(cl = cl) %>%
    calc_molecular_weight(cl = cl) %>%
    calc_number_of_atoms(cl = cl) %>%
    calc_sequence_entropy(cl = cl) %>%
    calc_conjoint_triads(cl = cl)

  # Add Npeptide percentages
  for (i in 1:max.N){
    df <- calc_Npeptide_composition(df, N = i, cl = cl)
  }

  # Sort data.table (The variable names are initialised below just to
  # prevent NOTEs on CRAN. The data.table ordering uses references to variables
  # internal to df)
  Info_sourceOrg_id <- Info_protein_id <- NULL
  Info_epitope_id   <- Info_center_pos <- NULL
  df <- df[order(Info_sourceOrg_id, Info_protein_id, Info_epitope_id,
                 Info_center_pos), ]

  if("cluster" %in% class(cl)) parallel::stopCluster(cl)

  return(df)
}
