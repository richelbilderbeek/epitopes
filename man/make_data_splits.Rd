% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/make_data_splits.R
\name{make_data_splits}
\alias{make_data_splits}
\title{Split epitope data.}
\usage{
make_data_splits(
  peptides.list,
  proteins,
  split_level = "protein",
  split_prop = c(0.75, 0.25),
  similarity_threshold = 0.7,
  substitution_matrix = "BLOSUM62",
  alpha = 0.5,
  SAopts = list(),
  save_folder = NULL,
  ncpus = 1
)
}
\arguments{
\item{peptides.list}{list object returned by \code{\link[=extract_peptides]{extract_peptides()}}, containing
the data frame of windowed epitope data (\strong{df}) and the data frame of
individual peptides (\strong{peptides}).}

\item{proteins}{data frame of proteins, returned by \code{\link[=get_proteins]{get_proteins()}}
containing all proteins listed in \code{peptides.list$df$Info_protein_id}.}

\item{split_level}{which sequences should be used to calculate similarity
for splitting the data.
Accepts "protein" (uses similarity of the full protein sequences,
\code{proteins$TSeq_sequence}, to determine which observations should stay
together in the splits) or "peptide" (uses similarity of the labelled
peptides, \code{peptides.list$peptides$Info_peptide}).
See \strong{Grouping strategy} for details.}

\item{split_prop}{numeric vector of target proportions for each split
(i.e., a vector (p1, p2, ..., pK) such that 0 < pk < 1 for all k and
sum(pk) = 1).}

\item{similarity_threshold}{similarity threshold for grouping observations.
See \strong{Grouping strategy} for details.}

\item{substitution_matrix}{character string indicating the substitution
matrix to be used to calculate the peptide / protein alignments.
Must be a matrix recognised by \code{\link[Biostrings:substitution_matrices]{Biostrings::substitution.matrices()}}
(e.g., "BLOSUM45", "PAM30", etc.)}

\item{alpha}{weight parameter to regulate focus on maximising match to desired
split proportions (\code{split_prop}) vs. on approximating the class
balance of the full data set. Must be a numeric value between 0 and 1.
See \strong{Optimisation Problem} for details.}

\item{SAopts}{list of control parameters to be used by the simulated
annealing (SANN) algorithm. See \code{\link[stats:optim]{stats::optim()}} for details.}

\item{save_folder}{path to folder for saving the results. It will save the
results as file \emph{peptides_list.rds} (overwriting if necessary)}

\item{ncpus}{positive integer, number of cores to use.}
}
\value{
A list object containing:
\itemize{
\item \strong{df}: \code{peptides.list$df} updated to contain cluster number and
split allocation of each entry
\item \strong{peptides}: \code{peptides.list$peptides} updated to contain cluster
number and split allocation of each entry
\item \strong{proteins}: data frame containing data on all proteins listed in
\code{df$Info_protein_id}.
\item \strong{peptide.attrs}: list inherited from \code{peptides.list}, containing
relevant attributes used in the earlier call to \code{\link[=extract_peptides]{extract_peptides()}}.
\item \strong{splits.attrs}: list containing information about the splitting:
\itemize{
\item \emph{split_level}: same as input parameter \code{split_level}
\item \emph{similarity_threshold}: same as input parameter \code{similarity_threshold}
\item \emph{substitution_matrix}: same as input parameter \code{substitution_matrix}
\item \emph{split_props}: proportion of data allocated to each split
\item \emph{split_balance}: proportion of positive observations in each split
\item \emph{target_props}: same as input parameter \code{split_prop}
\item \emph{target_balance}: proportion of positive observations in full data
\item \emph{alpha}: same as input parameter \code{alpha}
\item \emph{SW.scores}: local alignment scores between each sequence (Smith-Waterman)
\item \emph{diss.matrix}: dissimilarity matrix (see \strong{Grouping strategy} for details)
\item \emph{clusters}: \code{hclust} object with clustering structure.
\item \emph{cluster.alloc}: data frame with cluster allocations
\item \emph{alloc.summary}: list summarising which clusters were allocated to each split
}
}

If the splitting is impossible (e.g., if the number of clusters is smaller
than the desired number of splits) the function throws a warning and returns
a list with only \strong{SW.scores}, \strong{diss.matrix} and \strong{clusters}.
}
\description{
Split the windowed epitope data returned by \code{\link[=extract_peptides]{extract_peptides()}} into
non-overlapping subsets. Proteins / peptides with similarities higher than
a predefined threshold are always placed in the same split to prevent data
leakage in machine learning. This routine tries to simultaneously approximate
the user-defined proportions and maintain the overall class balance within
each split.
}
\section{\strong{Grouping strategy}}{

The first step of this routine is to group the observations at either the
proteins or the peptide level (depending on input parameter \code{split_level}).
Local alignment scores for all pairs of sequences are calculated using the
implementation of the Smith-Waterman algorithm available in function
\code{\link[Biostrings:pairwiseAlignment]{Biostrings::pairwiseAlignment()}}, with default parameters and the scoring
matrix defined in \code{substitution_matrix}. These scores are returned as
element \strong{SW.scores} of the output list.

The dissimilarity matrix is calculated based on \strong{SW.scores}, as:

\code{diss[i,j] = 1 - SW.scores[i,j] / min(SW.scores[i,i], SW.scores[j,j])}

which gives a value between 0 (perfect similarity) and 1 (maximum
dissimilarity). \code{diss[i,j]} will be 0 if and only if the shorter sequence is
fully and perfectly contained in the longer one; and will be 1 if and only
if the Smith-Waterman alignment score is zero.

The dissimilarity matrix (returned as element \strong{diss.matrix} of the output
list) is used to calculate a hierarchical clustering of
the sequences, and input parameter \code{similarity_threshold} is then used to
define the resulting similarity clusters. Single-linkage is used, to
guarantee that any pair of sequences with similarity
greater than the threshold will always be contained within the same cluster.
The resulting clusters (returned as element \strong{clusters} of the output list)
represent the allocation units that are considered by the optimisation
to split the data.
}

\section{Optimisation Problem}{

This routine attempts to simultaneously minimise two objectives: (i) the
difference between the actual proportion of data within each split and the
desired levels informed by \code{split_prop}, and (ii) the difference between the
proportion of \emph{positive} observations within each split and the overall
proportion in the data. A simple linear aggregation strategy is used to
define the following optimisation problem. Let:
\itemize{
\item nC:  number of clusters.
\item K:   number of splits.
\item xi:  integer variable defining the split to which cluster i is allocated.
\item Ni+: number of \emph{positive} observations in cluster i.
\item Ni:  total number of observations in cluster i.
\item Gj*: desired proportion of data for split j.
\item P*:  proportion of \emph{positive} observations in the whole data.
}

We want to solve the problem:

\verb{minimize sum_j\{ alpha x (Gj - Gj*)^2 + (1-alpha) x (pj - P*)^2 \}}

With:
\itemize{
\item \verb{xi \\in \{1, ..., K\}}, for all \verb{i = 1, ..., nC}
\item \code{yij = ifelse(xi == j, 1, 0)}
\item \verb{Gj = sum_i\{ yij * Ni \} / sum_i\{ Ni \}}
\item \verb{pj = sum_i\{ yij * Ni+ \} / sum_i\{ yij * Ni \}}
}

Input parameter \code{alpha} regulates the relative importance attributed to
each of the two objectives. At the limits, \code{alpha = 0} ignores the desired
proportions and
focuses only on defining splits with class balances that are as close as
possible to \strong{P*}, whereas \code{alpha = 0} ignores the class balance and tries
to simply generate splits that are as faithful as possible to the desired
proportions. An approximation to the Pareto-optimal front can be obtained
by varying \code{alpha} between these two values.

The search space of this optimisation problem has a cardinality of
\code{K ^ nC}. If the cardinality is under \code{10^6} possible
allocations then this routine performs enumerative search and is guaranteed
to return the global optimum. For larger search spaces a
constructive heuristic followed by Simulated Annealing (see \code{\link[stats:optim]{stats::optim()}}
for details) is used. Input parameter \code{SAopts} can be used to pass control
parameters to the Simulated Annealing.
}

\author{
Felipe Campelo (\email{f.campelo@aston.ac.uk})
}
